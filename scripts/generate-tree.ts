#!/usr/bin/env node

/**
 * ng-alain å°ˆæ¡ˆçµæ§‹æ¨¹ç‹€åœ–ç”Ÿæˆè…³æœ¬ï¼ˆç°¡åŒ–ç‰ˆï¼‰
 * ç”Ÿæˆå…©ä»½æ–‡ä»¶ï¼š
 * 1. ng-alain-structure-folders.md - åªæœ‰è³‡æ–™å¤¾çµæ§‹
 * 2. ng-alain-structure-full.md - å®Œæ•´çµæ§‹ï¼ˆå«æ–‡ä»¶ï¼‰
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

// ============================================================
// æ’é™¤è¦å‰‡
// ============================================================

const EXCLUDE_PATTERNS: readonly string[] = [
  'dist', '.angular', 'node_modules', '.git', '.vscode', '.idea',
  'coverage', '__tests__', 'e2e', '.eslintcache', '.stylelintcache',
  '*.log', '*.tmp', '.DS_Store', '.env*', '_cli-tpl', '.cursor',
  '.github', '.husky', '.yarn', 'scripts'
] as const;

const EXCLUDE_EXTENSIONS: readonly string[] = [
  '.map', '.spec.ts', '.spec.js', '.log', '.tmp', '.swp', '.bak'
] as const;

// ============================================================
// æ ¸å¿ƒåŠŸèƒ½
// ============================================================

/**
 * æª¢æŸ¥è·¯å¾‘æ˜¯å¦æ‡‰è©²è¢«æ’é™¤
 */
function shouldExclude(filePath: string, fileName: string): boolean {
  // æª¢æŸ¥æ’é™¤æ¨¡å¼
  for (const pattern of EXCLUDE_PATTERNS) {
    if (pattern.includes('*')) {
      const regex = new RegExp(pattern.replace(/\*/g, '.*'));
      if (regex.test(fileName)) return true;
    } else {
      if (fileName === pattern) return true;
      const pathParts = filePath.split(path.sep);
      if (pathParts.includes(pattern)) return true;
    }
  }

  // æª¢æŸ¥æ–‡ä»¶æ“´å±•å
  const ext = path.extname(fileName);
  if (EXCLUDE_EXTENSIONS.includes(ext)) return true;

  return false;
}

/**
 * ç”Ÿæˆæ¨¹ç‹€çµæ§‹
 * @param dirPath - ç›®éŒ„è·¯å¾‘
 * @param prefix - å‰ç¶´å­—ç¬¦ä¸²
 * @param isLast - æ˜¯å¦ç‚ºæœ€å¾Œä¸€å€‹é …ç›®
 * @param depth - ç•¶å‰æ·±åº¦
 * @param maxDepth - æœ€å¤§æ·±åº¦
 * @param foldersOnly - æ˜¯å¦åªé¡¯ç¤ºè³‡æ–™å¤¾
 */
function generateTree(
  dirPath: string,
  prefix: string = '',
  isLast: boolean = true,
  depth: number = 0,
  maxDepth: number = 10,
  foldersOnly: boolean = false
): string {
  if (depth > maxDepth) {
    return prefix + (isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ') + '...\n';
  }

  let result = '';
  let items: fs.Dirent[] = [];

  try {
    items = fs.readdirSync(dirPath, { withFileTypes: true })
      .filter((item: fs.Dirent) => {
        // æ’é™¤ä¸éœ€è¦çš„æ–‡ä»¶/ç›®éŒ„
        if (shouldExclude(path.join(dirPath, item.name), item.name)) return false;
        // å¦‚æœåªé¡¯ç¤ºè³‡æ–™å¤¾ï¼Œéæ¿¾æ‰æ–‡ä»¶
        if (foldersOnly && !item.isDirectory()) return false;
        return true;
      });
  } catch (error) {
    return result;
  }

  // æ’åºï¼šç›®éŒ„å„ªå…ˆï¼Œç„¶å¾ŒæŒ‰åç¨±æ’åº
  items = items.sort((a: fs.Dirent, b: fs.Dirent) => {
    if (a.isDirectory() && !b.isDirectory()) return -1;
    if (!a.isDirectory() && b.isDirectory()) return 1;
    return a.name.localeCompare(b.name);
  });

  items.forEach((item: fs.Dirent, index: number) => {
    const isLastItem = index === items.length - 1;
    const currentPrefix = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
    const nextPrefix = isLast ? '    ' : 'â”‚   ';

    result += `${prefix}${currentPrefix}${item.name}`;

    if (item.isDirectory()) {
      result += '/\n';
      const subPath = path.join(dirPath, item.name);
      result += generateTree(subPath, prefix + nextPrefix, isLastItem, depth + 1, maxDepth, foldersOnly);
    } else {
      result += '\n';
    }
  });

  return result;
}

/**
 * çµ±è¨ˆæ–‡ä»¶å’Œç›®éŒ„æ•¸é‡
 */
function countItems(dirPath: string, foldersOnly: boolean = false): { files: number; folders: number } {
  let files = 0;
  let folders = 0;

  function walk(dir: string): void {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      for (const item of items) {
        if (shouldExclude(path.join(dir, item.name), item.name)) continue;

        if (item.isDirectory()) {
          folders++;
          walk(path.join(dir, item.name));
        } else if (!foldersOnly) {
          files++;
        }
      }
    } catch {
      // å¿½ç•¥ç„¡æ³•è®€å–çš„ç›®éŒ„
    }
  }

  walk(dirPath);
  return { files, folders };
}

/**
 * ç”Ÿæˆ Markdown æ–‡ä»¶
 */
function generateMarkdown(tree: string, title: string, description: string, stats: { files: number; folders: number }): string {
  const timestamp = new Date().toISOString().split('T')[0];

  return `# ${title}

> ${description}

**ç”Ÿæˆæ™‚é–“**: ${timestamp}

## ğŸ“Š çµ±è¨ˆè³‡è¨Š

- **ç›®éŒ„ç¸½æ•¸**: ${stats.folders}
${stats.files > 0 ? `- **æ–‡ä»¶ç¸½æ•¸**: ${stats.files}` : ''}

## ğŸ“‚ ç›®éŒ„çµæ§‹

\`\`\`
${tree.trim()}
\`\`\`

---

*Generated by ng-alain Structure Generator (Simplified)*
`;
}

/**
 * ä¸»å‡½æ•¸ï¼šç”Ÿæˆå°ˆæ¡ˆçµæ§‹æ–‡ä»¶
 */
function generateProjectStructure(): void {
  const rootPath = process.cwd();
  const outputDir = path.join(rootPath, 'memory-bank');

  // ç¢ºä¿è¼¸å‡ºç›®éŒ„å­˜åœ¨
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  console.log('ğŸ” é–‹å§‹ç”Ÿæˆå°ˆæ¡ˆçµæ§‹...\n');

  // ============================================================
  // 1. ç”Ÿæˆè³‡æ–™å¤¾çµæ§‹ï¼ˆåªæœ‰ç›®éŒ„ï¼‰
  // ============================================================
  console.log('ğŸ“ ç”Ÿæˆè³‡æ–™å¤¾çµæ§‹...');
  const folderTree = generateTree(rootPath, '', true, 0, 10, true);
  const folderStats = countItems(rootPath, true);
  const folderContent = generateMarkdown(
    folderTree,
    'ğŸ“ ng-alain å°ˆæ¡ˆè³‡æ–™å¤¾çµæ§‹',
    'åƒ…åŒ…å«ç›®éŒ„çµæ§‹ï¼Œä¸åŒ…å«æ–‡ä»¶',
    folderStats
  );

  const folderOutputPath = path.join(outputDir, 'ng-alain-structure-folders.md');
  fs.writeFileSync(folderOutputPath, folderContent, 'utf8');
  console.log(`âœ… è³‡æ–™å¤¾çµæ§‹å·²ç”Ÿæˆ: ${folderOutputPath}`);
  console.log(`   ğŸ“Š ç›®éŒ„ç¸½æ•¸: ${folderStats.folders}\n`);

  // ============================================================
  // 2. ç”Ÿæˆå®Œæ•´çµæ§‹ï¼ˆåŒ…å«æ–‡ä»¶ï¼‰
  // ============================================================
  console.log('ğŸ“„ ç”Ÿæˆå®Œæ•´çµæ§‹...');
  const fullTree = generateTree(rootPath, '', true, 0, 10, false);
  const fullStats = countItems(rootPath, false);
  const fullContent = generateMarkdown(
    fullTree,
    'ğŸ“„ ng-alain å°ˆæ¡ˆå®Œæ•´çµæ§‹',
    'åŒ…å«å®Œæ•´çš„ç›®éŒ„å’Œæ–‡ä»¶çµæ§‹',
    fullStats
  );

  const fullOutputPath = path.join(outputDir, 'ng-alain-structure-full.md');
  fs.writeFileSync(fullOutputPath, fullContent, 'utf8');
  console.log(`âœ… å®Œæ•´çµæ§‹å·²ç”Ÿæˆ: ${fullOutputPath}`);
  console.log(`   ğŸ“Š ç›®éŒ„ç¸½æ•¸: ${fullStats.folders}`);
  console.log(`   ğŸ“Š æ–‡ä»¶ç¸½æ•¸: ${fullStats.files}\n`);

  console.log('ğŸ‰ å°ˆæ¡ˆçµæ§‹ç”Ÿæˆå®Œæˆï¼');
}

// ============================================================
// åŸ·è¡Œè…³æœ¬
// ============================================================
if (require.main === module) {
  try {
    generateProjectStructure();
  } catch (error) {
    console.error('âŒ ç”Ÿæˆå°ˆæ¡ˆçµæ§‹æ™‚ç™¼ç”ŸéŒ¯èª¤:', (error as Error).message);
    process.exit(1);
  }
}

// å°å‡ºå‡½æ•¸ä¾›å…¶ä»–æ¨¡çµ„ä½¿ç”¨
export { generateProjectStructure, generateTree };
