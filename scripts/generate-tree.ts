#!/usr/bin/env node

/**
 * ng-alain 專案結構樹狀圖生成腳本（簡化版）
 * 生成兩份文件：
 * 1. ng-alain-structure-folders.md - 只有資料夾結構
 * 2. ng-alain-structure-full.md - 完整結構（含文件）
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { execSync } from 'node:child_process';

// ============================================================
// 排除規則
// ============================================================

const EXCLUDE_PATTERNS: readonly string[] = [
  'dist', '.angular', 'node_modules', '.git', '.vscode', '.idea',
  'coverage', '__tests__', 'e2e', '.eslintcache', '.stylelintcache',
  '*.log', '*.tmp', '.DS_Store', '.env*', '_cli-tpl', '.cursor',
  '.github', '.husky', '.yarn', 'scripts'
] as const;

const EXCLUDE_EXTENSIONS: readonly string[] = [
  '.map', '.spec.ts', '.spec.js', '.log', '.tmp', '.swp', '.bak'
] as const;

// ============================================================
// 核心功能
// ============================================================

/**
 * 檢查路徑是否應該被排除
 */
function shouldExclude(filePath: string, fileName: string): boolean {
  // 檢查排除模式
  for (const pattern of EXCLUDE_PATTERNS) {
    if (pattern.includes('*')) {
      const regex = new RegExp(pattern.replace(/\*/g, '.*'));
      if (regex.test(fileName)) return true;
    } else {
      if (fileName === pattern) return true;
      const pathParts = filePath.split(path.sep);
      if (pathParts.includes(pattern)) return true;
    }
  }

  // 檢查文件擴展名
  const ext = path.extname(fileName);
  if (EXCLUDE_EXTENSIONS.includes(ext)) return true;

  return false;
}

/**
 * 生成樹狀結構
 * @param dirPath - 目錄路徑
 * @param prefix - 前綴字符串
 * @param isLast - 是否為最後一個項目
 * @param depth - 當前深度
 * @param maxDepth - 最大深度
 * @param foldersOnly - 是否只顯示資料夾
 */
function generateTree(
  dirPath: string,
  prefix: string = '',
  isLast: boolean = true,
  depth: number = 0,
  maxDepth: number = 10,
  foldersOnly: boolean = false
): string {
  if (depth > maxDepth) {
    return prefix + (isLast ? '└── ' : '├── ') + '...\n';
  }

  let result = '';
  let items: fs.Dirent[] = [];

  try {
    items = fs.readdirSync(dirPath, { withFileTypes: true })
      .filter((item: fs.Dirent) => {
        // 排除不需要的文件/目錄
        if (shouldExclude(path.join(dirPath, item.name), item.name)) return false;
        // 如果只顯示資料夾，過濾掉文件
        if (foldersOnly && !item.isDirectory()) return false;
        return true;
      });
  } catch (error) {
    return result;
  }

  // 排序：目錄優先，然後按名稱排序
  items = items.sort((a: fs.Dirent, b: fs.Dirent) => {
    if (a.isDirectory() && !b.isDirectory()) return -1;
    if (!a.isDirectory() && b.isDirectory()) return 1;
    return a.name.localeCompare(b.name);
  });

  items.forEach((item: fs.Dirent, index: number) => {
    const isLastItem = index === items.length - 1;
    const currentPrefix = isLast ? '└── ' : '├── ';
    const nextPrefix = isLast ? '    ' : '│   ';

    result += `${prefix}${currentPrefix}${item.name}`;

    if (item.isDirectory()) {
      result += '/\n';
      const subPath = path.join(dirPath, item.name);
      result += generateTree(subPath, prefix + nextPrefix, isLastItem, depth + 1, maxDepth, foldersOnly);
    } else {
      result += '\n';
    }
  });

  return result;
}

/**
 * 統計文件和目錄數量
 */
function countItems(dirPath: string, foldersOnly: boolean = false): { files: number; folders: number } {
  let files = 0;
  let folders = 0;

  function walk(dir: string): void {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      for (const item of items) {
        if (shouldExclude(path.join(dir, item.name), item.name)) continue;

        if (item.isDirectory()) {
          folders++;
          walk(path.join(dir, item.name));
        } else if (!foldersOnly) {
          files++;
        }
      }
    } catch {
      // 忽略無法讀取的目錄
    }
  }

  walk(dirPath);
  return { files, folders };
}

/**
 * 生成 Markdown 文件
 */
function generateMarkdown(tree: string, title: string, description: string, stats: { files: number; folders: number }): string {
  const timestamp = new Date().toISOString().split('T')[0];

  return `# ${title}

> ${description}

**生成時間**: ${timestamp}

## 📊 統計資訊

- **目錄總數**: ${stats.folders}
${stats.files > 0 ? `- **文件總數**: ${stats.files}` : ''}

## 📂 目錄結構

\`\`\`
${tree.trim()}
\`\`\`

---

*Generated by ng-alain Structure Generator (Simplified)*
`;
}

/**
 * 執行 Lint 檢查並生成報告
 */
function runLintAndSaveReport(): void {
  const rootPath = process.cwd();
  const outputDir = path.join(rootPath, 'memory-bank');
  const outputPath = path.join(outputDir, 'ng-alain-lint-error.md');

  console.log('🔍 開始執行 Lint 檢查...\n');

  // 執行 TypeScript Lint
  console.log('📝 執行 TypeScript Lint (ESLint)...');
  let tsLintOutput = '';
  let tsLintSuccess = true;
  try {
    tsLintOutput = execSync('npx eslint --cache', {
      encoding: 'utf8',
      stdio: 'pipe',
    });
  } catch (error: any) {
    tsLintSuccess = false;
    // 即使有錯誤，也從 error.stdout 和 error.stderr 獲取輸出
    tsLintOutput = (error.stdout || '') + (error.stderr || '');
  }

  // 執行 Style Lint
  console.log('🎨 執行 Style Lint (Stylelint)...');
  let styleLintOutput = '';
  let styleLintSuccess = true;
  try {
    styleLintOutput = execSync("npx stylelint 'src/**/*.less'", {
      encoding: 'utf8',
      stdio: 'pipe',
    });
  } catch (error: any) {
    styleLintSuccess = false;
    styleLintOutput = (error.stdout || '') + (error.stderr || '');
  }

  // 分析結果
  const tsErrors = (tsLintOutput.match(/✖ \d+ problem/g) || [])[0] || '無錯誤';
  const styleErrors = (styleLintOutput.match(/✖ \d+ problem/g) || [])[0] || '無錯誤';

  // 生成 Markdown 報告
  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
  const report = `# 📋 ng-alain Lint 錯誤報告

> 自動生成的程式碼品質檢查報告

**生成時間**: ${timestamp}

## 📊 檢查摘要

| 檢查類型 | 狀態 | 結果 |
|---------|------|------|
| TypeScript (ESLint) | ${tsLintSuccess ? '✅ 通過' : '❌ 發現問題'} | ${tsErrors} |
| Style (Stylelint) | ${styleLintSuccess ? '✅ 通過' : '❌ 發現問題'} | ${styleErrors} |

## 🔍 詳細報告

### TypeScript Lint (ESLint)

${tsLintSuccess ? '✅ **無錯誤** - 程式碼符合 ESLint 規範' : ''}

\`\`\`
${tsLintOutput.trim() || '(無輸出)'}
\`\`\`

### Style Lint (Stylelint)

${styleLintSuccess ? '✅ **無錯誤** - 樣式檔案符合 Stylelint 規範' : ''}

\`\`\`
${styleLintOutput.trim() || '(無輸出)'}
\`\`\`

## 💡 建議修復步驟

### 自動修復
\`\`\`bash
# 自動修復 TypeScript 問題
npm run lint:ts

# 自動修復 Style 問題
npm run lint:style
\`\`\`

### 手動檢查
如果自動修復無法解決所有問題，請：
1. 檢查上述詳細報告中的錯誤訊息
2. 根據 ESLint/Stylelint 規則進行手動修正
3. 參考 Memory Bank 中的程式碼規範文件

## 📚 相關文件

- [程式碼規範](./implementation/code/codeStandards.md)
- [ESLint 配置](../eslint.config.mjs)
- [Stylelint 配置](../stylelint.config.mjs)

---

*Generated by ng-alain Structure Generator - Lint Report Module*
`;

  // 寫入報告
  fs.writeFileSync(outputPath, report, 'utf8');
  
  console.log(`✅ Lint 報告已生成: ${outputPath}`);
  if (!tsLintSuccess || !styleLintSuccess) {
    console.log(`   ⚠️  發現問題，請查看報告詳情`);
  } else {
    console.log(`   ✨ 所有檢查通過！`);
  }
  console.log('');
}

/**
 * 主函數：生成專案結構文件
 */
function generateProjectStructure(): void {
  const rootPath = process.cwd();
  const outputDir = path.join(rootPath, 'memory-bank');

  // 確保輸出目錄存在
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  console.log('🔍 開始生成專案結構與 Lint 報告...\n');

  // ============================================================
  // 1. 執行 Lint 檢查
  // ============================================================
  runLintAndSaveReport();

  // ============================================================
  // 2. 生成資料夾結構（只有目錄）
  // ============================================================
  console.log('📁 生成資料夾結構...');
  const folderTree = generateTree(rootPath, '', true, 0, 10, true);
  const folderStats = countItems(rootPath, true);
  const folderContent = generateMarkdown(
    folderTree,
    '📁 ng-alain 專案資料夾結構',
    '僅包含目錄結構，不包含文件',
    folderStats
  );

  const folderOutputPath = path.join(outputDir, 'ng-alain-structure-folders.md');
  fs.writeFileSync(folderOutputPath, folderContent, 'utf8');
  console.log(`✅ 資料夾結構已生成: ${folderOutputPath}`);
  console.log(`   📊 目錄總數: ${folderStats.folders}\n`);

  // ============================================================
  // 3. 生成完整結構（包含文件）
  // ============================================================
  console.log('📄 生成完整結構...');
  const fullTree = generateTree(rootPath, '', true, 0, 10, false);
  const fullStats = countItems(rootPath, false);
  const fullContent = generateMarkdown(
    fullTree,
    '📄 ng-alain 專案完整結構',
    '包含完整的目錄和文件結構',
    fullStats
  );

  const fullOutputPath = path.join(outputDir, 'ng-alain-structure-full.md');
  fs.writeFileSync(fullOutputPath, fullContent, 'utf8');
  console.log(`✅ 完整結構已生成: ${fullOutputPath}`);
  console.log(`   📊 目錄總數: ${fullStats.folders}`);
  console.log(`   📊 文件總數: ${fullStats.files}\n`);

  console.log('🎉 專案結構與 Lint 報告生成完成！');
}

// ============================================================
// 執行腳本
// ============================================================
if (require.main === module) {
  try {
    generateProjectStructure();
  } catch (error) {
    console.error('❌ 生成專案結構時發生錯誤:', (error as Error).message);
    process.exit(1);
  }
}

// 導出函數供其他模組使用
export { generateProjectStructure, generateTree };
